<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>A71CH Host Sw: HLSE (Generic) API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">A71CH Host Sw
   &#160;<span id="projectnumber">v01.05.00</span>
   </div>
   <div id="projectbrief">NXP Semiconductors</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('page_hlse_generic_api.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">HLSE (Generic) API </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="genAPI"></a>
HLSE API</h1>
<p>The API is designed to be generic for Secure Elements that hold cryptographic information and perform cryptographic functions. It isolates an application from the details of the cryptographic device such that it does not have to change to interface to a different type of cryptographic device.</p>
<p>This generic layer intends to abstract both the different APDU specs of applets, and the “file system” details, i.e., how each “object” is stored on the SE. For example, in order to enumerate the certificate objects on the card, the implementation should know where the objects are located, how many there are, what their type is, etc. This abstract layer is important for, e.g. a PKCS#11 layer, and for TLS engines that will have to access objects on the Secure Element.</p>
<p>The HLSE API is written in ‘C’ allowing maximal portability across different platforms.</p>
<p>Each typedef, enum and function starts with the HLSE (=Host Library Secure Element) prefix.</p>
<p>The various Secure Element entities are referred to as Objects. Every Object (e.g. Key) has a unique handle (HLSE_OBJECT_HANDLE) and a set of attributes (<a class="el" href="struct_h_l_s_e___a_t_t_r_i_b_u_t_e.html">HLSE_ATTRIBUTE</a>) whose values can be retrieved (Get) and Set. An HLSE_OBJECT_HANDLE can be obtained in two ways: Either returned by <a class="el" href="_h_l_s_e_objects_8h.html#a9ca5b6eedab2e1482f2c1827b5b9c4c4">HLSE_EnumerateObjects()</a> if the Object exists on the Secure Element, or returned by <a class="el" href="_h_l_s_e_objects_8h.html#acb251dca3f805f24c2c08bd838f8c32c">HLSE_CreateObject()</a> for a new Object. This is an abstraction of the actual way in which the API implements these handles.</p>
<p>An <a class="el" href="struct_h_l_s_e___a_t_t_r_i_b_u_t_e.html">HLSE_ATTRIBUTE</a> is defined as: <br />
 </p><pre class="fragment"> typedef struct HLSE_ATTRIBUTE {
    HLSE_ATTRIBUTE_TYPE     type;
    void*                   value;
    U16                     valueLen;
} HLSE_ATTRIBUTE;
</pre><p>For example, a Private RSA key may have the HLSE_ATTR_RSA_MODULUS and HLSE_ATTR_RSA_PUBLIC_EXPONENT attributes, and their values can be extracted or set.</p>
<p>Key Generation can be obtained by passing a NULL parameter in the HLSE_ATTR_OBJECT_VALUE attribute. This enables to create the key with a generated random data, or to re-generate an existing key by passing NULL in this attribute’s parameter.</p>
<p>A set of functions is responsible for performing cryptographic operations:</p><ul>
<li><a class="el" href="_h_l_s_e_crypto_8h.html#af1df44f639cc040093748b9112cad4f0">HLSE_Digest()</a></li>
<li><a class="el" href="_h_l_s_e_crypto_8h.html#ac2e354cd9324a4d01fd28a0cb8bb247a">HLSE_Sign()</a></li>
<li><a class="el" href="_h_l_s_e_crypto_8h.html#a4dc0a26a9c63686dd85de7667c0f9b14">HLSE_VerifySignature()</a></li>
<li><a class="el" href="_h_l_s_e_crypto_8h.html#a42c72e32be0255e08453ef5f7163dafe">HLSE_DeriveKey()</a></li>
<li><a class="el" href="_h_l_s_e_crypto_8h.html#ad8d480e1a67be1f54c09ccd74f58d865">HLSE_Encrypt()</a></li>
<li><a class="el" href="_h_l_s_e_crypto_8h.html#a93490bc2d7e55d642aeb5f2b3bb4c7c8">HLSE_Decrypt()</a></li>
</ul>
<p>The cryptographic algorithm is controlled by a <a class="el" href="struct_h_l_s_e___m_e_c_h_a_n_i_s_m___i_n_f_o.html" title="MechanismInfo - maintains the mechanism type, with an optional additional parameter. ">HLSE_MECHANISM_INFO</a>, defined as:</p>
<pre class="fragment">typedef struct HLSE_MECHANISM_INFO {
    HLSE_MECHANISM_TYPE    mechanism;
    void*                  pParameter;
    U16                    ulParameterLen;
} HLSE_MECHANISM_INFO;
</pre><p>A list of the supported mechanisms, either by the library or by a specific key, can be obtained by calling <a class="el" href="_h_l_s_e_crypto_8h.html#a32359c81061353722390e054c9f206a2">HLSE_GetSupportedMechanisms()</a> or <a class="el" href="_h_l_s_e_crypto_8h.html#af1a65ace762b0fba97b0c590656021de">HLSE_GetSupportedMechanismsForObject()</a>, respectively.</p>
<p>The HLSE API is made up of four parts:</p><ul>
<li>Operations on Objects (<a class="el" href="_h_l_s_e_objects_8h.html">HLSEObjects.h</a>)</li>
<li>Cryptographic operations (<a class="el" href="_h_l_s_e_crypto_8h.html">HLSECrypto.h</a>)</li>
<li>Secure Element Communication and Secure Channel management functions (<a class="el" href="_h_l_s_e_comm_8h.html">HLSEComm.h</a>)</li>
<li>Debug Mode variant and miscellaneous functionality (<a class="el" href="_h_l_s_e_misc_8h.html">HLSEMisc.h</a>)</li>
</ul>
<p>An additional file <a class="el" href="_h_l_s_e_a_p_i_8h.html">HLSEAPI.h</a> serves as an entry point to the full API. The implementation of the API dealing with A71CH specific functionality is in <a class="el" href="_a71_h_l_s_e_wrapper_8c.html">A71HLSEWrapper.c</a>.</p>
<h2><a class="anchor" id="hcApi"></a>
Host Crypto API</h2>
<p>The interface between the host library and the cryptographic library that provides services for the Secure Channel (e.g. SCP03) is in <a class="el" href="_host_crypto_a_p_i_8h.html">HostCryptoAPI.h</a>. An implementation of this API using OpenSSL is given in <a class="el" href="_host_crypto_a_p_i_open_s_s_l_8c.html">HostCryptoAPIOpenSSL.c</a>. This API allows to perform cryptographic operation required by the host library in order to implement the host side of the Secure Channel protocol with the Secure Element.</p>
<h2><a class="anchor" id="logicalObjects"></a>
Logical objects</h2>
<p>The HLSE API allows to create logical objects in the GP Storage. They can be of HLSE_CERTIFICATE or HLSE_DATA object type. The abstraction for various objects that reside in the GP Storage area is achieved by maintaining a lookup table (mapping) at the end of the GP Storage area to hold information about the logical objects that exist in the GP Storage. The structure of the table is as follows: </p><pre class="fragment">Notes:
    X+1 is the address of the last byte of the GP Storage.
    N is the object number from 1 to N

Address     Value
-------     ----------------------
X-N*6+0     N’th Object Class       - 1 byte
X-N*6+1     N’th Object Index       - 1 byte
X-N*6+2     N’th Object Length MSB  - 1 byte
X-N*6+3     N’th Object Length LSB  - 1 byte
X-N*6+4     N’th Object Offset MSB  - 1 byte
X-N*6+5     N’th Object Offset LSB  - 1 byte
            …
X-1*6+0     First Object Class      - 1 byte
X-1*6+1     First Object Index      - 1 byte
X-1*6+2     First Object Length MSB - 1 byte
X-1*6+3     First Object Length LSB - 1 byte
X-1*6+4     First Object Offset MSB - 1 byte
X-1*6+5     First Object Offset LSB - 1 byte

X           Update Counter          - 1 byte
X+1         Number of table entries - 1 byte
End of GP Storage
</pre><p>The table will be written so that the 'Number of table entries' byte is the last byte of the GP Data (to allow the map to grow dynamically as long as there is enough free space), preceded by one byte of the Update Counter and then preceded by 6-tuples of entries.<br />
The Class byte is equivalent to the object type using a single byte (0x09 for Certificate, 0x0A for Data).<br />
The order of the 6-tuple entries is not important, as each object is identified by its Class and Index.<br />
In cases where the length of an object is not known at the time the lookup table entry is created, the MSBit (0x8000) can be set in the length as an indicator that the data is in TLV format and that the actual length must be obtained by reading the first bytes of the object’s data.</p>
<p>For objects of type 'Certificate' the provisioned 'Object Length' value must be one of the following:</p><ul>
<li>The reserved object storage length (allowing for a possible increase in size of the certificate or for die-individual variance of the certificate size).</li>
<li>The actual certificate length</li>
<li>In the exceptional case neither a reserved certificate object storage length nor the effective certificate length can be determined one can use the value '0x8000' to indicate the 'Object Size' is unknown at the time of provisioning.</li>
</ul>
<p>When reading a certificate from GP storage with the HLSE API, the size of the certificate is always determined by the length value of the certificate’s initial TL(V) header.</p>
<p>The host library reads the total number of entries in the table from the last byte of the GP Data, followed by parsing/reading the 6-tuple entries. Up to 254 (0xFE) objects are assumed. A value of 0xFF in the number of entries indicates that the table is absent (uninitialized) or invalid.<br />
 Class and Index value of 0xFF indicates an invalid entry (i.e. of a deleted object).<br />
 The Update Counter is initially set to 0 and it is incremented on each table update. This serves as an indication to a GP Storage’s change when there is more than one application updating the SE concurrently.<br />
 The value of 'object offset' must be a multiple of 32.<br />
 It is not allowed to create a data object of size 0.<br />
</p>
<h2><a class="anchor" id="autotoc_md1"></a>
Object creation</h2>
<p>The library supports a dynamic number of objects in the GP Storage, according to the memory availability. <br />
 Creating an object through <a class="el" href="_h_l_s_e_objects_8h.html#acb251dca3f805f24c2c08bd838f8c32c">HLSE_CreateObject()</a> requires the following attributes to be passed:</p><ol type="1">
<li>HLSE_ATTR_OBJECT_TYPE – currently HLSE_CERTIFICATE or HLSE_DATA;</li>
<li>HLSE_ATTR_OBJECT_INDEX – will be the Tag of the object, 1 byte;</li>
<li>HLSE_ATTR_OBJECT_VALUE – the object’s value.</li>
</ol>
<p>An additional attribute that can only be passed in Create is HLSE_ATTR_READ_ONLY. Setting this value to 1 will lock ('freeze') the memory associated with the object (once it has been created) so it cannot be modified. The HLSE_ATTR_READ_ONLY attribute is not explicitly stored in the GP Storage lookup table.</p>
<p>Note that this attribute cannot be set after object creation. If not passed, it has a default value of 0 (can be modified).</p>
<p>Creation fails if there is not enough continuous unlocked space for the new object’s value.</p>
<h2><a class="anchor" id="autotoc_md2"></a>
Value Update</h2>
<p>It is possible to change the object’s value by calling <a class="el" href="_h_l_s_e_objects_8h.html#a36fe72bc902d0e484fda14dc75d4c34f">HLSE_SetObjectAttribute()</a> with HLSE_ATTR_OBJECT_VALUE. If the object needs to be enlarged, it is only permitted if enough memory is available for the object to grow, case as follows:</p><ol type="1">
<li>Within the same GP Storage’s chunk size (32 bytes), so that the same amount of storage chunks will be used - For example, if the size was originally 21 bytes then the object occupies 1 chunk, and it is possible to enlarge it up to 32 bytes.</li>
<li>Up to the offset of the next allocated object in the GP memory.</li>
</ol>
<p>If a larger size is required, the object must first be erased and then re-created (assuming a sufficiently large continuous unlocked space is available in GP memory).</p>
<h2><a class="anchor" id="autotoc_md3"></a>
Direct Access Value Update</h2>
<p>It is possible to change a sub section of a Data object’s value by calling <a class="el" href="_h_l_s_e_objects_8h.html#a36fe72bc902d0e484fda14dc75d4c34f">HLSE_SetObjectAttribute()</a> with HLSE_ATTR_DIRECT_ACCESS_OBJECT_VALUE, where the value should point to a <a class="el" href="struct_h_l_s_e___d_i_r_e_c_t___a_c_c_e_s_s___a_t_t_r_i_b_u_t_e___v_a_l_u_e.html">HLSE_DIRECT_ACCESS_ATTRIBUTE_VALUE</a> structure that passes the offset, number of bytes to read and the buffer. The update is only permitted within the object's GP Storage’s chunk boundary.</p>
<h2><a class="anchor" id="autotoc_md4"></a>
Erasing an object</h2>
<p>To erase an object first fetch its handle with <a class="el" href="_h_l_s_e_objects_8h.html#a9ca5b6eedab2e1482f2c1827b5b9c4c4">HLSE_EnumerateObjects()</a> and call <a class="el" href="_h_l_s_e_objects_8h.html#a5ad65dcc386661827b5f51d48f921cd1">HLSE_EraseObject()</a>. Erasing an object only invalidates its lookup table entry, it does not erase its value contents in the GP Storage, due to performance reasons.</p>
<h2><a class="anchor" id="autotoc_md5"></a>
Interoperability of Object storage and locked chunks</h2>
<p>The following defines the behavior of the HLSE API when updating (full/partial) or erasing partially locked objects stored in GP memory:</p><ol type="1">
<li>When updating an object (by definition this concerns the complete object) the HLSE API first checks that no chunk of the object is locked before updating the object.</li>
<li>When doing a partial update of an object the HLSE API does not check whether the affected memory chunks(s) are locked or unlocked. The partial update will fail or succeed accordingly. Consequently one must only issue a partial update of an object for chunks that are unlocked.</li>
<li>When erasing an object, the <a class="el" href="_h_l_s_e_objects_8h.html#a9ca5b6eedab2e1482f2c1827b5b9c4c4">HLSE_EnumerateObjects()</a> API checks whether the first chunk of the object is locked. If the first chunk is not locked the entry corresponding to the object is removed from the GP lookup table. If the first chunk is locked, the object is considered 'read-only' and the object is not removed from the GP lookup table. As explained above, erasing an object does not erase the value associated with the object.</li>
<li>Locking the GP storage chunks containing the lookup table (even a partial lock) will make it impossible to remove, add or update objects.</li>
</ol>
<h2><a class="anchor" id="autotoc_md6"></a>
Notes</h2>
<ol type="1">
<li>If the applet is Trust Provisioned prior to being shipped to the user, with e.g. one or more certificate(s), then the lookup table is expected to be in the GP Data.</li>
<li>If the lookup table is missing (invalid value), then it is automatically created by the host library upon the first call to CreateObject of such an object.</li>
<li>When reading a certificate, the response omits any trailing padding at the end of the certificate. The size of the certificate is determined by the length value of the certificates initial TL(V) header.</li>
<li>When updating an Object - the length in the GP table will be kept as the maximum size of the existing and new the object. As a consequence, it's not possible to shrink the size of an object by updating it.</li>
<li>Don’t use direct A71CH API access in combination with the HLSE Object API as one can damage the lookup table or the value of stored objects.</li>
</ol>
<h1><a class="anchor" id="autotoc_md7"></a>
HLSE API Examples</h1>
<p><a class="el" href="hlsea71ch_ex.html">HLSE API Examples</a></p>
<h1><a class="anchor" id="sw_structure_hlse"></a>
SW Structure</h1>
<p>The following picture illustrates the HLSE layer (generic API) in the context of the overall Host SW. </p><div class="image">
<object type="image/svg+xml" data="A71CH_HLSE_SW_Layers.svg">A71CH_HLSE_SW_Layers.svg</object>
<div class="caption">
HLSE &amp; Host Library SW Layers</div></div>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri Sep 7 2018 19:24:07 for A71CH Host Sw by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
